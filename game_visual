import pygame, math, random
from string import ascii_lowercase as acl
from archive.game import Die
# Initialize Pygame
pygame.init()

# Constants

FPS = 60
WHITE = (255, 255, 255)

screen = pygame.display.set_mode((1200, 800))
WIDTH, HEIGHT = pygame.display.get_window_size()
pygame.display.set_caption("Great Filter")

RED = (255, 0,  0)
PURPLE = (128, 0, 128)
ORANGE = (255, 165, 0)
BLACK = (0, 0, 0)

GREEN = pygame.Color("#A1FB03")
BLUE = pygame.Color("#01E3FD")
BROWN = pygame.Color("#C19A6B")

HEX_SIZE = WIDTH/22
TILE_SPAWN = (5*WIDTH//6, 5*HEIGHT//6)

pygame.font.init()
info_font = pygame.font.SysFont("verdana", 15)
hex_font = pygame.font.SysFont("verdana", 10)

fancy_font = pygame.font.SysFont(name='vivaldi', size=125)
basic_font_small = pygame.font.SysFont(name='arial', size=12)
basic_font_large = pygame.font.SysFont(name='arial', size=int(HEIGHT/45))
basic_font_xl = pygame.font.SysFont(name='arial', size=72, bold=True)

# Create the game window


# Clock to control frame rate
clock = pygame.time.Clock()


#Miscellaneous Methods
def shuffle(input_list: list): 
    for n in range(1000): 
        a = random.randint(0, len(input_list)-1)
        input_list.append(input_list.pop(a))
    return input_list

def roll_dice(die_value): 
    return random.randint(1, die_value)

def generate_text(text, fg, bg, rect_center, border=None, border_width=5, font=basic_font_large):
    return_text = font.render(text, True, fg, bg)
    return_rect = return_text.get_rect()
    return_rect.center = rect_center
    if border:
        border_rect = return_rect.inflate(border_width, border_width)
        return (return_text, return_rect, (border, border_rect))
    return return_text, return_rect

#Game Tokens

class City: 
    def __init__(self, color):
        self.sprite = None
        edge = int(HEIGHT/57.6)
        self.dimensions = (edge, edge)
        self.placed = False
        self.color = color

    def place(self, pos):
        x, y = pos
        w, h = self.dimensions
        pygame.draw.rect(screen, self.color
                         , pygame.rect.Rect(x - w/2, y - h/2, w, h))
        self.placed = True



class Plot: 
    def __init__(self, spot, composition, value):
        self.index = acl[spot]
        self.buildable = composition[spot] == 'l'
        self.occupied = False
        self.token = None
        self.connections = []
        self.center = None

        self.identity = (value, self.index)
        self.adjacency = None



#Visual Elements
class HexTile: 
    def __init__(self, composition, value):
        self.x, self.y = 0, 0
        self.coordinate = None

        composition_list = ['llllll', 'lllllw',  'llllww', 'lllwww', 'llwwww', 'llwwww', 'llwwww', 'llwwww']
        self.colors = {'l':GREEN, 'w':BLUE}
        self.composition = composition_list[composition]
        self.rotation = random.randint(0, 5)
        self.value = value
        self.adjacencies = None
        self.plots = [
            Plot(n, self.composition, value)
            for n in range(6)            
        ]


        self.place()

    def set_location(self, x, y): 
        self.x = x
        self.y = y

    def set_coordinates(self, col, row): 
        self.coordinate = (col, row)
    def place(self): 
        #draw hexagon
        self.tile = pygame.draw.polygon(screen, BLACK, [(self.x + HEX_SIZE * math.cos(math.radians(angle)), self.y + HEX_SIZE * math.sin(math.radians(angle))) for angle in range(0, 360, 60)], 10)
        tile_letters = ['a', 'b', 'c', 'd', 'e', 'f']
        for angle in range(0, 360, 60):
            index = (angle//60 + self.rotation) % 6
            #draw hex triangle fill
            pygame.draw.polygon(screen, self.colors[self.composition[index]], 
                                [(self.x, self.y), 
                                 (self.x + (HEX_SIZE - 4) * math.cos(math.radians(angle)), self.y + (HEX_SIZE - 4) * math.sin(math.radians(angle))), 
                                 (self.x + (HEX_SIZE - 4) * math.cos(math.radians(angle+60)), self.y + (HEX_SIZE - 4) * math.sin(math.radians(angle+60)))]
            )
            #draw hex triangle line
            pygame.draw.polygon(screen, BLACK, 
                                [(self.x, self.y), 
                                 (self.x + (HEX_SIZE) * math.cos(math.radians(angle)), self.y + (HEX_SIZE) * math.sin(math.radians(angle))), 
                                 (self.x + (HEX_SIZE) * math.cos(math.radians(angle+60)), self.y + (HEX_SIZE) * math.sin(math.radians(angle+60)))
                                ], width=3
            )
            self.plots[index].center = (self.x + (HEX_SIZE/2) * math.cos(math.radians(angle+30)), self.y + (HEX_SIZE/2) * math.sin(math.radians(angle+30)))
        for angle, letter in zip(range(0, 360, 60), tile_letters):
            tile_letter = hex_font.render(letter, True, BLACK)
            screen.blit(tile_letter, ((self.x + (HEX_SIZE-HEX_SIZE/4) * math.cos(math.radians(angle+30 - 60*self.rotation))-tile_letter.width/2, self.y + (HEX_SIZE-25) * math.sin(math.radians(angle+30-60*self.rotation))-tile_letter.height/2)))

    def adjacency_debug(self): 
        for angle in range(0, 360, 60):
            adjaceny_value = hex_font.render(str(int(self.adjacencies[angle//60])), True, BLACK)
            screen.blit(adjaceny_value, ((self.x + (HEX_SIZE-HEX_SIZE/4) * math.cos(math.radians(angle+30 - 60*self.rotation))-adjaceny_value.width/2, self.y + (HEX_SIZE-25) * math.sin(math.radians(angle+30-60*self.rotation))-adjaceny_value.height/2)))


class HexGrid: 
    def __init__(self):
        self.grid = [[None for _ in range(5)] for _ in range(4)]
        self.tile_list = [None for _ in range(20)]
        self.printed = False
        self.tile_highlight = None
        self.printed = False

    def draw_hexagon(self, surface, color, position, size):
        x, y = position
        points = [(x + size * math.cos(math.radians(angle)), y + size * math.sin(math.radians(angle))) for angle in range(0, 360, 60)]
        pygame.draw.polygon(surface, color, points, 2)

    def draw_hex_grid(self, rows, cols, hex_size, tiles):
        grid_width = (cols - 1) * (1.5 * hex_size) + hex_size
        grid_height = (rows - 1) * (hex_size * math.sqrt(3)) + hex_size * math.sqrt(3)
        offset_x = (WIDTH - grid_width) / 2 + 50
        offset_y = (HEIGHT - grid_height) / 3
        index = 0
        for row in range(rows):
            for col in range(cols):
                tile: HexTile = tiles[index]
                x = col * hex_size * 1.5 + offset_x
                y = row * hex_size * math.sqrt(3) + (hex_size * math.sqrt(3) / 2 * (col % 2)) + offset_y
                tile.set_location(x, y)
                tile.set_coordinates(col, row)
                tile.place()
                pygame.draw.circle(screen, BLACK, (x, y), 10)
                hex_num = hex_font.render(str(tile.value)+" "+str(tile.rotation), True, WHITE)
                screen.blit(hex_num, (x - hex_num.width/2, y- hex_num.height/2))
                self.grid[row][col] = tile
                self.tile_list[tile.value-1] = tile
                index += 1
        
        for row in range(rows): 
            for col in range(cols): 
                self.detect_adjacencies(row, col)
                tile:HexTile
                tile = self.grid[row][col]
                # tile.adjacency_debug()
        



    def detect_adjacencies(self, row, col):
        def rotate_list(data):
            if not data:
                return data
            last_element = data[-1]
            rotated_list = [last_element] + data[:-1]
            return rotated_list
        tile: HexTile
        tile = self.grid[row][col]
        rotation = tile.rotation
        adjacencies = [
            (col != 4) and (row != 3 or col%2 == 0), 
            (row != 3), 
            (col != 0) and (row != 3 or col%2 == 0), 
            (col != 0) and (row != 0 or col%2 == 1), 
            (row != 0), 
            (col != 4) and (row != 0 or col%2 == 1)
        ]
        for _ in range(rotation): 
            adjacencies = rotate_list(adjacencies)
        tile.adjacencies = adjacencies
        plot: dict
        for plot in tile.plots: 
            ...     
    
class InfoBar: 
    def __init__(self, players: list):
        self.players = players
        self.round_btn = pygame.Rect(WIDTH*2/5, 4.5*HEIGHT/6,2*WIDTH/10, 0.3*HEIGHT/6)
        width_scale = 0.035 * HEIGHT/ (WIDTH+HEIGHT)
        height_scale = 0.035 * WIDTH/ (WIDTH+HEIGHT)
        self.resource_icons = (
            ('water', pygame.transform.scale(
            pygame.image.load('assets/droplet.png'), (WIDTH* width_scale, HEIGHT* height_scale))),
            ('food', pygame.transform.scale(
            pygame.image.load('assets/food.png'), (WIDTH* width_scale, HEIGHT* height_scale))),
            ('wood', pygame.transform.scale(
            pygame.image.load('assets/log.png'), (WIDTH* width_scale, HEIGHT* height_scale))),
            ('brick', pygame.transform.scale(
            pygame.image.load('assets/stone.png'), (WIDTH* width_scale, HEIGHT* height_scale))) 
        )

        self.die_icons = {
            4: pygame.transform.scale(
            pygame.image.load('assets/dice/d4.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
            6:pygame.transform.scale(
            pygame.image.load('assets/dice/d6.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
            8:pygame.transform.scale(
            pygame.image.load('assets/dice/d8.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
            10:pygame.transform.scale(
            pygame.image.load('assets/dice/d10.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
            12:pygame.transform.scale(
            pygame.image.load('assets/dice/d12.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
            20:pygame.transform.scale(
            pygame.image.load('assets/dice/d20.png'), (WIDTH * width_scale, HEIGHT* height_scale)),
        }

        self.round_num = 1

    def draw_sections(self): 
        offset = (WIDTH/150, HEIGHT/300)
        main_box = [(WIDTH/10, 5*HEIGHT/6), (8*WIDTH/10, 0.7*HEIGHT/6)]
        round_num_box = [(WIDTH/10, 5*HEIGHT/6-HEIGHT/25), (WIDTH/10, 0.2*HEIGHT/6)]
        pygame.draw.rect(screen, WHITE, main_box)
        pygame.draw.rect(screen, BLACK, main_box, width=4)
        for n in range(4): 
            pygame.draw.rect(screen, BLACK, [(main_box[0][0]+(n)*WIDTH/5, main_box[0][1]), (main_box[1][0]/4, main_box[1][1])], width=1)
            player: Player = self.players[n]
            screen.blit(player.name, (WIDTH/10+(n)*WIDTH/5 + offset[0], 5*HEIGHT/6 + offset[1]))
            #place icons on infobar
            for index, icon in enumerate(self.resource_icons):
                screen.blit(icon[1], (WIDTH/10+(n)*WIDTH/5 + 2 * offset[0] + index * 5 * offset[0], 5*HEIGHT/6 + 8 * offset[1]))
                value_text, value_rect = generate_text(str(player.resources[icon[0]]), BLACK, WHITE, (WIDTH/10+(n)*WIDTH/5 + 2 * offset[0] + index * 5 * offset[0] + WIDTH/45, 5*HEIGHT/6 + 8 * offset[1] + HEIGHT/100))
                screen.blit(value_text, value_rect)
            die: Die
            for index, die in enumerate(player.dice): 
                screen.blit(self.die_icons[die.value], (WIDTH/10+(n)*WIDTH/5 + 2 * offset[0] + index * 5 * offset[0], 5*HEIGHT/6 + 8 * offset[1] + HEIGHT / 20 ))

        #next round button
        pygame.draw.rect(screen, GREEN, self.round_btn)
        pygame.draw.rect(screen, BLACK, self.round_btn, 5)
        text, text_rect = generate_text("Play Round",  BLACK, GREEN, self.round_btn.center)
        screen.blit(text, text_rect)
        round_value, round_value_rect = generate_text(f"Round {self.round_num}", BLACK, BROWN, pygame.Rect(round_num_box).center)
        screen.blit(round_value, round_value_rect)



#Technical Elements

class GameEngine: 
    def __init__(self, game, tiles, grid: HexGrid):
        self.players = [Player(0, RED), Player(1, PURPLE), Player(2, ORANGE), Player(3, BLACK)]
        self.assign_players()
        start_pos_set = False
        self.game = game
        self.grid = grid
        self.info_bar = InfoBar(self.players)
        self.draw_screen(tiles)
        self.set_start()

    def draw_screen(self, tiles): 
        screen.fill(BROWN)  # Clear the screen with white
        self.grid.draw_hex_grid(4, 5, HEX_SIZE, tiles)
        self.place_tokens()
        self.info_bar.draw_sections()

    def place_tokens(self): 
        tile: HexTile
        for tile in self.grid.tile_list: 
            plot: Plot
            for plot in tile.plots: 
                if plot.occupied:
                    plot.token.place(plot.center)
                    

    def assign_players(self): 
        for n, player in enumerate(self.players): 
            player.set_name(f"Player {n+1}")

    def set_start(self): 
        for player in self.players: 
            start_value = roll_dice(20)
            player.start_pos = start_value
            player.choose_start(self.grid)

    def play_round(self):
        self.info_bar.round_num += 1
        for player in self.players:
            player.roll_action()
            player.purchase_action()
            player.card_action()


class Player: 
    def __init__(self, position, color): 
        self.name = None
        self.position = position
        self.color=color
        self.start_pos = None

        self.cities = [City(self.color) for _ in range(5)]

        self.resources = {
            'water': 0,
            'food': 0,
            'wood': 0,
            'brick': 0
        }
        self.dice = [Die()]

    def set_name(self, name):
        self.name = info_font.render(name, True, BLACK)

    def choose_start(self, grid: HexGrid): 
        spawn_tile: HexTile = grid.tile_list[self.start_pos-1]
        for plot in spawn_tile.plots:
            if plot.buildable and not plot.occupied:
                plot.occupied = True
                placed, index = True, 0
                while placed:
                    try:
                        token = self.cities[index]
                        placed = token.placed
                        if not placed: 
                            plot.token = token
                            return
                        index += 1
                    except IndexError:
                        break
        self.start_pos = roll_dice(20)
        self.choose_start(grid)
    
    def roll_action(self): 
        die: Die
        for die in self.dice: 
            roll_value = die.roll()
            self.resources[die.die_resources[roll_value]] += 1
    
    def purchase_action(self):
        ...

    def card_action(self): 
        ...



class Game: 
    def __init__(self):
        self.main()

    # Game loop
    def main(self):
        tile_dragging = False   
        #initial conditions

        tiles = shuffle([HexTile(n%8, n+1) for n in range(20)])
        grid = HexGrid()
        engine = GameEngine(self,tiles, grid)
        choosing_tile = False
        quit_button = pygame.Rect(9/10*WIDTH, HEIGHT/30, WIDTH/12, HEIGHT/20)
        quit_text, quit_rect = generate_text("Quit Sim", BLACK, GREEN, quit_button.center)
        




        running = True
        while running:
            clock.tick(FPS)  # Limit the frame rate
            
            # Event handling
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False

                if event.type == pygame.MOUSEBUTTONUP:
                    if engine.info_bar.round_btn.collidepoint(event.pos):
                        engine.play_round()
                    
                    if quit_button.collidepoint(event.pos): 
                        running = False

                
                #Code for drag and dropping tiles, moot due to auto-assigment, may be revisited in the future. 


                # elif event.type == pygame.MOUSEBUTTONDOWN:
                #     if event.button == 1:            
                #         if tile.tile.collidepoint(event.pos):
                #             tile_dragging = True
                #             mouse_x, mouse_y = event.pos
                #             offset_x = tile.x - mouse_x
                #             offset_y = tile.y - mouse_y
                #             print('click')

                # elif event.type == pygame.MOUSEBUTTONUP:
                #     if event.button == 1:            
                #         tile_dragging = False

                # elif event.type == pygame.MOUSEMOTION:
                #     if tile_dragging:
                #         mouse_x, mouse_y = event.pos
                #         tile.x = mouse_x + offset_x
                #         tile.y = mouse_y + offset_y


            # Game logic goes here
            
            # Drawing
            engine.draw_screen(tiles)
            pygame.draw.rect(screen, GREEN, quit_button)
            pygame.draw.rect(screen, BLACK, quit_button, 5)
            screen.blit(quit_text, quit_rect)


            
            # Update display
            pygame.display.flip()



        # Quit Pygame
        pygame.quit()

if __name__ == "__main__": 
    game = Game()
